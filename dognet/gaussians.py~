import torch
import torch.nn as nn

from torch.autograd import Variable
from torch.nn.parameter import Parameter

class Gaussian_2D_isotropic(nn.Module):
    def __init__(self,w,n_gaussian,learn_A=False):
        super(Gaussian_2D_isotropic, self).__init__()
        self.s = Parameter(torch.randn(n_gaussian).float().cuda(),requires_grad=True)
	
	self.A = None
	if learn_A:
        	self.A = Parameter(torch.randn(n_gaussian).float().cuda(),requires_grad=True)
          
        self.xes = torch.FloatTensor(range(-w/2+1,w/2+1))            
        self.xes = Variable(self.xes.repeat(self.xes.size(0),1),requires_grad=False).unsqueeze(-1).cuda()
        self.xes = self.xes.repeat(1,1,n_gaussian)
        self.yes = self.xes.transpose(1,0)
              
        self.padding = w/2
        
    def _get_filter(self,s,A):
        s = s.abs()
        s = s.expand(self.xes.size(0),self.xes.size(1),s.size(0))
	if A:
        	A = A.expand(self.xes.size(0),self.xes.size(1),A.size(0))
	else:
		A = 1./(s+1e-8)

        fiters = A*( - (self.xes**2 + self.yes**2)/(2*s**2)).exp()
        return fiters.transpose(0,2).unsqueeze(1).contiguous()
    
    def forward(self,x):        
        fiters = self._get_filter(self.s,self.A)
        return F.conv2d(x,fiters, padding=self.padding,groups=x.size(1))


class Gaussian_2D_anisotropic(nn.Module):
"""
Gaussian for anistropic case. Learns for each filter sx,sy (spread x,y), th (rotation angle), A (amplitude). 
"""
    def __init__(self,w,n_gaussian,th=None,learn_A=True):
        super(Gaussian_2D_anisotropic, self).__init__()
        self.sx = Parameter(torch.randn(n_gaussian).float().cuda(),requires_grad=True)
        self.sy = Parameter(torch.randn(n_gaussian).float().cuda(),requires_grad=True)
	self.th = th
	if self.th is None:
        	self.th = Parameter(torch.randn(n_gaussian).float().cuda(),requires_grad=True)

	if learn_A:
        	self.A = Parameter(torch.randn(n_gaussian).float().cuda(),requires_grad=True)
        else:
		self.A = None

        self.xes = torch.FloatTensor(range(-w/2+1,w/2+1))            
        self.xes = Variable(self.xes.repeat(self.xes.size(0),1),requires_grad=False).unsqueeze(-1).cuda()
        self.xes = self.xes.repeat(1,1,n_gaussian)
        self.yes = self.xes.transpose(1,0)
            
        self.padding = w/2
    
    def _get_filter(self,sx,sy,theta,A):
        sx = sx.abs()
        sy = sy.abs()
        
        a = theta.cos()**2/(2*sx**2) + theta.sin()**2/(2*sy**2)
        b = -(2*theta).sin()/(4*sx**2) + (2*theta).sin()/(4*sy**2)
        c = theta.sin()**2/(2*sx**2) + theta.cos()**2/(2*sy**2)

        a = a.expand(self.xes.size(0),self.xes.size(1),a.size(0))
        b = b.expand(self.xes.size(0),self.xes.size(1),b.size(0))
        c = c.expand(self.xes.size(0),self.xes.size(1),c.size(0))
        if A:
        	A = A.expand(self.xes.size(0),self.xes.size(1),A.size(0))
	else:
		A = 2./(sx+sy+1e-8)

        fiters = A*( - (a*self.xes**2 + 2*b*self.xes*self.yes + c*self.yes**2)).exp()
                    
        return fiters.transpose(0,2).unsqueeze(1).contiguous()
           
    def forward(self,x):        
        fiters = self._get_filter(self.sx,self.sy,self.th,self.A)
        return F.conv2d(x,fiters, padding=self.padding,groups=x.size(1))

